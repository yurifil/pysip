from pysip.message.hnames import TOPMOST_VIA_HEADER, TO_HEADER, FROM_HEADER, CALLID_HEADER, CSEQ_HEADER, VIA_HEADER
from pysip.message.branch import make_rfc3261, Branch
from pysip.message.pysip_id import token
from pysip.message.sip_message import SipMessage, NotFound
from pysip import PySIPException
import hashlib


DROP = 'drop'
FORWARD = 'forward'

VIA_NOT_MATCH = 'via_not_match'
NO_MORE_VIA = 'no_more_via'
VIA_NO_BRANCH = 'via_no_branch'


class ProcessResponseResult(object):
    pass


class ProcessResponseDrop(ProcessResponseResult):
    def __init__(self, reason=None):
        self.state = DROP
        self.reason = reason


class ProcessResponseForward(ProcessResponseResult):
    def __init__(self, sip_msg=None):
        self.state = FORWARD
        self.message = sip_msg


class StatelessProxyError(PySIPException):
    pass


class StatelessProxy(object):
    @staticmethod
    def check_via_branch(branch):
        # TODO check against generated by branch() method.
        return True

    @staticmethod
    def branch(sip_msg):
        # The proxy examines the branch ID in the topmost Via header field of the received request.  If it begins with
        # the magic cookie, the first component of the branch ID of the outgoing request is computed as a hash of the
        # received branch ID.  Otherwise, the first component of the branch ID is computed as a hash of the topmost
        # Via, the tag in the To header field, the tag in the From header field, the Call-ID header field, the CSeq
        # number (but not method), and the Request-URI from the received request.  One of these fields will always vary
        # across two different transactions.
        topmost_via = sip_msg.topmost_via
        if topmost_via.branch is None:
            print(f'StatelessProxy.branch(): None')
            return StatelessProxy.rfc2543_based_branch(sip_msg)
        else:
            if topmost_via.branch.is_rfc3261():
                return StatelessProxy.rfc3261_based_branch(topmost_via.branch)
            else:
                return StatelessProxy.rfc2543_based_branch(sip_msg)

    @staticmethod
    def process_response(previous_via, raw_message):
        try:
            sip_msg = SipMessage.parse(raw_message, [])
            if previous_via.branch is not None:
                if StatelessProxy.check_via_branch(previous_via.branch):
                    topmostvia = sip_msg.topmost_via
                    if isinstance(topmostvia, NotFound):
                        return ProcessResponseDrop(reason=NO_MORE_VIA)
                    return ProcessResponseForward(sip_msg=sip_msg)
                return ProcessResponseDrop(reason=VIA_NOT_MATCH)
            return ProcessResponseDrop(reason=VIA_NO_BRANCH)
        except Exception as e:
            raise StatelessProxyError(f'Cannot parse message: {e}')

    @staticmethod
    def rfc3261_based_branch(branch):
        if isinstance(branch, Branch):
            return make_rfc3261(token(branch.binary))
        else:
            raise StatelessProxyError(f'{branch} is not a {Branch.__name__} instance.')

    @staticmethod
    def rfc2543_based_branch(sip_message):
        to_hdr, from_hdr, topmostvia_hdr, callid_hdr, cseq_hdr = sip_message.get(TO_HEADER), \
                                                                 sip_message.get(FROM_HEADER), \
                                                                 sip_message.topmost_via, \
                                                                 sip_message.get(CALLID_HEADER), \
                                                                 sip_message.get(CSEQ_HEADER)
        to_hash = f'{topmostvia_hdr.assemble()}&{to_hdr.tag}&{from_hdr.tag}&{callid_hdr.assemble()}${cseq_hdr.number}'
        hash_result = hashlib.md5(to_hash.encode('utf8')).hexdigest()
        return make_rfc3261(hash_result)

'''
-spec rfc3261_based_branch(ersip_branch:branch()) -> ersip_branch:branch().
rfc3261_based_branch({branch, Bin}) ->
    ersip_branch:make_rfc3261(ersip_id:token(Bin)).


-spec rfc2543_based_branch(ersip_sipmsg:sipmsg()) -> ersip_branch:branch().
rfc2543_based_branch(SipMsg) ->
    %% Otherwise, the first component of the branch ID is computed as
    %% a hash of the topmost Via, the tag in the To header field, the
    %% tag in the From header field, the Call-ID header field, the
    %% CSeq number (but not method), and the Request-URI from the
    %% received request.  One of these fields will always vary across
    %% two different transactions.
    [To, From, TopMostVia, CallId, CSeq]
        = [ersip_sipmsg:get(X, SipMsg) || X <- [to, from, topmost_via, callid, cseq]],
    ToBeHashed =
        [ersip_hdr_via:assemble(TopMostVia), <<"&">>,
         get_tag(To), <<"&">>,
         get_tag(From), <<"&">>,
         ersip_hdr_callid:assemble(CallId), <<"&">>,
         integer_to_binary(ersip_hdr_cseq:number(CSeq))
        ],
    Hash = crypto:hash(md5, ToBeHashed),
    ersip_branch:make_rfc3261(ersip_id:token(Hash)).


%% 16.11 Stateless Proxy
%%
%% Response processing as described in Section 16.7 does not apply to
%% a proxy behaving statelessly.  When a response arrives at a
%% stateless proxy, the proxy MUST inspect the sent-by value in the
%% first (topmost) Via header field value.  If that address matches
%% the proxy, (it equals a value this proxy has inserted into previous
%% requests) the proxy MUST remove that header field value from the
%% response and forward the result to the location indicated in the
%% next Via header field value.  The proxy MUST NOT add to, modify, or
%% remove the message body.  Unless specified otherwise, the proxy
%% MUST NOT remove any other header field values.  If the address does
%% not match the proxy, the message MUST be silently discarded.

-spec process_response(PrevVia, RawMsg) -> process_response_result() when
      PrevVia :: ersip_hdr_via:via(),
      RawMsg  :: ersip_msg:message().
process_response(PrevVia, RawMsg) ->
    case ersip_sipmsg:parse(RawMsg, []) of
        {ok, SipMsg} ->
            case ersip_hdr_via:branch(PrevVia) of
                {ok, Branch} ->
                    case check_via_branch(Branch) of
                        match ->
                            %% Check if next via is still exist and forward
                            %% response there.
                            case ersip_sipmsg:find(topmost_via, SipMsg) of
                                not_found ->
                                    {drop, no_more_via};
                                {ok, _} ->
                                    {forward, SipMsg}
                            end;
                        mismatch ->
                            {drop, via_not_match}
                    end;
                undefined ->
                    {drop, via_no_branch}
            end;
        {error, _} = Error ->
            {drop, {parse_error, Error}}
    end.

%%%===================================================================
%%% Helpers
%%%===================================================================



-spec check_via_branch(ersip_branch:branch()) -> match | mismatch.
check_via_branch({branch, _} = Branch) ->
    %% TODO: check against generated by branch/1 function.
    match.

-spec get_tag(ersip_hdr_fromto:fromto()) -> binary().
get_tag(FromTo) ->
    case ersip_hdr_fromto:tag_key(FromTo) of
        undefined ->
            %% use & here to prevent collision with normal tags
            <<"&undef">>;
        {tag_key, TagKey} when is_binary(TagKey) ->
            TagKey
    end.
'''